'use strict';

/*
* Блок про ООП
*
* ООП - объектно ориентированное программирование - методология программирования, основанная на представлении программ
* в виде совокупности взаимодействующих объектов каждый из которых является экземпляром определенного класса, а классы
* образуют иерархию наследования.
* Принципы ООП: инкапсуляция, наследование, полиморфизм, абстракция
* - Инкапсуляция говорит о том, что данные объекта не должны быть напрямую доступны, а должны вызываться путем методов
* для доступа к данным. Инкапсулция позволяет нам скрывать/показывать свойства класса
* - Наследование - возможность дочерних классов наследовать свойства и методы от родительского класса
* - Абстракция - это использование только тех характеристик объекта, которые с достаточной точностью представляют его
* в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при
* этом с достаточной точностью для решаемой задачи.
* - Полиморфизм - возможность вызывать один и тот же метод для разных объектов и при этом каждый объект будет
* реагировать по-своему. Выделяют два вида полиморфизма: параметрический(истинный) и ad-hoc (мнимый)
* Перегрузка - это приём программирования, который позволяет разработчику в одном классе для методов с разными
* параметрами использовать одно и то же имя.
* Абстрактные классы - похожи на обычные классы, за исключением того, что мы не можем создавать нарямую экземпляр
* абстрактного класса, используя его конструктор. Абстрактные классы могут содержать абстрактные члены, принадлежность
* к которым указывается с помощью ключевого слова abstract. Ключевое слово abstract можно применить к полям, свойствам
* и методам абстрактного класса.
* */

/*
* Блок про Классы в JS
*
* В ооп класс - это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные
* значения (свойства) и реализацию поведения (методы).
* Свойства и методы бывают публичными и приватными. По соглашению перед названиями приватных свойств
* и методов ставится нижнее подчеркивание. Ниже weight сделал приватным, объявить значение можно только
* при создании экземпляра класса в конструкторе. Извне менять его мы не можем, но в самом
* классе можем к нему обращаться. Для публичных свойств созданы геттеры и сеттеры, для приватных только
* геттеры.
* Примесь – общий термин в объектно-ориентированном программировании: класс, который содержит в себе методы для
* других классов. Примесь определяет методы, которые реализуют определённое поведение. Мы не используем примесь саму
* по себе, а используем её, чтобы добавить функциональность другим классам.
* Ниже создадим класс Human - человек
* */

//Примесь
const sayHi = {
    say(phrase) {
        console.log(`Я говорю '${phrase}'`);
    }
}

class Human {
    name // Публичный, в ts можно было бы отметить модификатором public
    height // Публичный, public
    _weight // Приватный, в ts можно было бы отметить модификатором private

    order = 'primates' //Свойство: отряд - приматы
    static humanClass = 'mammals' //Статическое свойство: класс - млекопитающие, свойство самого класса

    // Конструктор, где объявляем имя, рост, вес
    constructor(name, height, weight) {
        this.name = name
        this.height = height
        this._weight = weight
    }
    // Геттеры - для чтения
    get name() {
        return this.name
    }

    get height() {
        return this.height
    }

    get weight() {
        return this._weight
    }
    //Сеттеры - для записи
    set name(value) {
        this.name = value
    }

    set height(value) {
        this.height = value
    }

    // Метод для расчета ИМТ.
    calculateBMI() {
        return this._weight/this.height**2
    }
    // Статический метод для расчета ИМТ. Он является методом всего класса
    static calculateBMIStatic(weight, height) {
        return weight/height**2
    }

    walk(a, b) {
        console.log(`Человек идет со скоростью ${a} м/с, ${b} километров`)
    }

    run() { // Метод, который выводит в логи сообщение, ниже переопределим метод
        console.log(`Я человек ${this.name}, и я бегу`)
    }
}

Object.assign(Human.prototype, sayHi); //Копируем методы
new Human('Vasia').say('Привет') // Я говорю 'Привет'

const human1 = new Human('ivan', 180, 70)
human1.weight = 10 // Cannot set property weight of #<Human> which has only a getter
console.log(human1.weight) // По итогу мы не смогли поменять вес, потому что существует только геттер


/*
* Создаем класс Работник, унаследованный от класса Человек, он примет все свойства и методы родительского класса
* */

class Employee extends Human {
    constructor(name, height, weight, salary) { //Конструктор
        super(name, height, weight) // Вызываем родительский конструктор
        this.salary = salary
    }
    // Переопределяем методы
    walk(c, d) {
        console.log(`Работник идет со скоростью ${c} км/ч, ${d} минут`)
    }

    run() {
        console.log(`Я работник ${this.name}, и я бегу`)
    }
}

const human2 = new Human('Ivan', 155, 99)
const employee2 = new Employee('Vasili', 190, 55, 50000)

//Из-за того, что мы переопределили метод, он работает по-разному в зависимости от экземпляра класса.
human2.walk(10,10) // Человек идет со скоростью 10 м/с, 10 километров
employee2.walk(10,10) // Работник идет со скоростью 10 км/ч, 10 минут
human2.run() // Я человек Ivan, и я бегу
employee2.run() // Я работник Vasili, и я бегу

// JavaScript не поддерживает перегрузку. Но можно использовать arguments.length

function overload() {
    if (arguments.length === 1) {
        console.log('Параметр')
    }
    if (arguments.length === 2) {
        console.log('Два параметра')
    }
}
overload(1);      // Один параметр
overload(1, 2);  // Два параметра